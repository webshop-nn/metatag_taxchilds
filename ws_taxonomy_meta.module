<?php

/**
 * @file
 * Primary module hooks for Метатэги наследников таксономии module.
 *
 * @DCG
 * This file is no longer required in Drupal 8.
 * @see https://www.drupal.org/node/2217931
 */

use \Drupal\Core\Form\FormStateInterface;
use \Drupal\Core\Entity\EntityInterface;

/**
 * Функция, добавляющая виджет в форм настроек таксономии
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function _ws_taxonomy_meta_settings_form(array &$form, FormStateInterface $form_state) {
	$entity = $form_state->getBuildInfo()['callback_object']->getEntity();
	$entity_type = $entity->getEntityType()->id();
	$config = Drupal::configFactory()->getEditable('ws_taxonomy_meta.' . $entity_type . '.' . $entity->id());

	$form['ws_taxonomy_meta'] = [
		'#type' => 'details',
		'#title' => t('Шаблон мета данных для наследников'),
		'#open' => false,
		'#weight' => 10
	];

	$form['ws_taxonomy_meta']['enable_override_meta'] = [
		'#type' => 'checkbox',
		'#title' => t('Переопределить мета данные наследников.'),
		'#default_value' => $config->get('enable_override')
	];

	$form['ws_taxonomy_meta']['meta_token_help'] = [
		'#theme' => 'token_tree_link',
		'#token_types' => ['node','commerce_product']
	];

	$form['ws_taxonomy_meta']['meta_title'] = [
		'#type'  => 'textfield',
		'#title' => 'Заголовок',
		'#size'  => 255,
		'#maxlength'  => 255,
		'#states' => [
			'visible' => [
				':input[name="enable_override_meta"]' => ['checked' => TRUE],
			]
		],
		'#default_value' => $config->get('title')
	];

	$form['ws_taxonomy_meta']['meta_description'] = [
		'#type'  => 'textarea',
		'#title' => 'Описание',
		'#states' => [
			'visible' => [
				':input[name="enable_override_meta"]' => ['checked' => TRUE],
			]
		],
		'#default_value' => $config->get('description')
	];

	$form['ws_taxonomy_meta']['meta_words'] = [
		'#type'  => 'textfield',
		'#title' => 'Ключевые слова',
		'#size'  => 255,
		'#maxlength'  => 255,
		'#states' => [
			'visible' => [
				':input[name="enable_override_meta"]' => ['checked' => TRUE],
			]
		],
		'#default_value' => $config->get('words')
	];

	$values_default = $config->get('alt_images');
	if (!is_array($values_default)) $values_default = [];
	$values = $form_state->get('num_images');
	if (empty($values)) {
		$values = count($values_default)+1;
		if ($values < 1) $values = 1;
	}

	$form_state->set('num_images',$values+1);

	$form['ws_taxonomy_meta']['alt_images'] = [
		"#type" => 'fieldset',
		"#title" => "ALT изображений",
		"#tree" => true,
		"#attributes" => [
			"id" => "taxonomy_meta_alt_images"
		],
		'#states' => [
			'visible' => [
				':input[name="enable_override_meta"]' => ['checked' => TRUE],
			]
		],
		"#tree" => true
	];
	for ($i = 0; $i < $values; $i++) {
		$form['ws_taxonomy_meta']['alt_images'][$i] = [ "#type" => "textfield" ];
		if (isset($values_default[$i]))
			$form['ws_taxonomy_meta']['alt_images'][$i]["#default_value"] = $values_default[$i];
	}

	$form['ws_taxonomy_meta']['alt_images_more'] = [
		"#type" => "button",
		"#value" => t("more"),
		"#ajax" => [
			'callback' => "ws_taxonomy_meta_alt_images_more_callback",
			'wrapper' => "taxonomy_meta_alt_images"
		]
	];

	$form['actions']['submit']['#submit'][] = 'ws_taxonomy_meta_submit_handler';
}
/**
 * Callback кнопки "Добавиь еще"
 */
function ws_taxonomy_meta_alt_images_more_callback(array &$form, FormStateInterface $form_state) {
	return $form['ws_taxonomy_meta']['alt_images'];
}

function ws_taxonomy_meta_preprocess_node(&$vars) {
	$metas = _ws_taxonomy_meta_get_meta($vars["node"]);
	$alt_images = [];
	if (isset($metas["alt_images"]) && is_array($metas["alt_images"]))
		$alt_images = $metas["alt_images"];
	
	$alt_images_length = count($alt_images);
	
	if ($alt_images_length > 0) {
		
		// Подставляем значения
		$token_service = \Drupal::token();
		foreach ($alt_images as $key => $item) {
			$alt_images[$key] = $token_service->replace($item, [ $metas["#context"]["entity_type"] => $metas["#context"]["entity"] ], ['clear' => true]);
		}
		
		// Записываем alt
		foreach($vars["content"] as &$item) {
			if (isset($item["#theme"]) && $item["#theme"] === "field" && isset($item["#field_type"]) && $item["#field_type"] === "image") {
				foreach ($item as $key => &$image) {
					if (is_int($key)) {
						if ((strlen($image["#item"]->alt) <= 0) && isset($alt_images[$key]))
							$image["#item_attributes"]["alt"] = $alt_images[$key];
					}
				}
			}
		}
	}
}
function ws_taxonomy_meta_preprocess_responsive_image_formatter(&$vars) {
	if (isset($vars["item_attributes"]["alt"]))
		$vars["responsive_image"]["#attributes"]["alt"] = $vars["item_attributes"]["alt"];
}
/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function ws_taxonomy_meta_form_taxonomy_term_form_alter(array &$form, FormStateInterface $form_state) {
	$entity = $form_state->getBuildInfo()['callback_object']->getEntity();
	if ($entity->id() !== NULL)
		_ws_taxonomy_meta_settings_form($form,$form_state);
}
/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function ws_taxonomy_meta_form_taxonomy_vocabulary_form_alter(array &$form, FormStateInterface $form_state) {
	$entity = $form_state->getBuildInfo()['callback_object']->getEntity();
	if ($entity->id() !== NULL)
		_ws_taxonomy_meta_settings_form($form,$form_state);
}
/**
 * Submit handler attached to term and vocabulary forms.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function ws_taxonomy_meta_submit_handler(array $form, FormStateInterface $form_state) {
	$entity = $form_state->getBuildInfo()['callback_object']->getEntity();
	$entity_type = $entity->getEntityType()->id();
	$form_values = $form_state->getValues();
	
	$alt_images = [];
	if (is_array($form_values['alt_images']))
	foreach ($form_values['alt_images'] as $item) {
		if (is_string($item) && strlen($item) > 0)
			$alt_images[] = $item;
	}

	if ($form_values["enable_override_meta"]) {
		\Drupal::configFactory()
			->getEditable('ws_taxonomy_meta.' . $entity_type . '.' . $entity->id())
			->set('enable_override', $form_values['enable_override_meta'])
			->set('title', $form_values['meta_title'])
			->set('description', $form_values['meta_description'])
			->set('words', $form_values['meta_words'])
			->set('alt_images', $alt_images)
			->save();
	} else {
		\Drupal::configFactory()
			->getEditable('ws_taxonomy_meta.' . $entity_type . '.' . $entity->id())
			->delete();
	}
}
/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function ws_taxonomy_meta_taxonomy_vocabulary_delete(EntityInterface $entity) {
	\Drupal::configFactory()->getEditable('ws_taxonomy_meta.'.$entity->getEntityType()->id().'.' . $entity->id())->delete();
}
/**
 * Implements hook_taxonomy_term_delete().
 */
function ws_taxonomy_meta_taxonomy_term_delete(EntityInterface $entity) {
	\Drupal::configFactory()->getEditable('ws_taxonomy_meta.'.$entity->getEntityType()->id().'.' . $entity->id())->delete();
}
/**
 * Функция анализирует параметры страницы и выдает мета данные
 * @return array
 */
function _ws_taxonomy_meta_get_meta(EntityInterface $entity = null) {
	$title = null;
	$description = null;
	$keywords = null;
	$alt_images = null;

	if ($entity === null) {
		
		$route_match = \Drupal::routeMatch();
		$entity = $route_match->getParameter('node');
		
		if (!is_object($entity)) {
			$entity = $route_match->getParameter('commerce_product');
		}
	}
	
	if ($entity === null || !is_object($entity))
		return [];

	$arr = $entity->toArray();
	foreach ($arr as $key => $value) {
		if ($entity->get($key) instanceof \Drupal\Core\Field\EntityReferenceFieldItemList) {

			$entity_term = $entity->get($key)->entity;
			if ($entity_term === null || $entity_term->getEntityTypeId() !== "taxonomy_term") continue;

			$config = \Drupal::configFactory()->get("ws_taxonomy_meta.taxonomy_term.".$entity_term->id());

			$finded = false;

			// Смотрим описание и слова у настроек таксономии
			if ($config->get("enable_override")) {
				$finded = true;
				$title = $config->get("title");
				if (is_string($title) && strlen($title) < 1)
					$title = null;
				$description = $config->get("description");
				if (is_string($description) && strlen($description) < 1)
					$description = null;
				$keywords = $config->get("words");
				if (is_string($keywords) && strlen($keywords) < 1)
					$keywords = null;
				
				$alt_images = $config->get("alt_images");

			// Если не найдены, то смотрим у родителей
			} else {
				$parent = $entity_term;
				while ($parent->parent->count() > 0) {
					$parent = $parent->parent->entity;
					if ($parent === null) break;

					$config = \Drupal::configFactory()->get("ws_taxonomy_meta.taxonomy_term.".$parent->id());
					if ($config->get("enable_override")) {
						$finded = true;
						$title = $config->get("title");
						if (is_string($title) && strlen($title) < 1)
							$title = null;
						$description = $config->get("description");
						if (is_string($description) && strlen($description) < 1)
							$description = null;
						$keywords = $config->get("words");
						if (is_string($keywords) && strlen($keywords) < 1)
							$keywords = null;
							
						$alt_images = $config->get("alt_images");
						break;
					}

				}
			}

			// Если не найдено, то смотрим у настроек типа таксономии
			if (!$finded) {
				$config = \Drupal::configFactory()->get("ws_taxonomy_meta.taxonomy_vocabulary.".$entity_term->vid->target_id);

				if ($config->get("enable_override")) {
					$title = $config->get("title");
					if (is_string($title) && strlen($title) < 1)
						$title = null;
					$description = $config->get("description");
					if (is_string($description) && strlen($description) < 1)
						$description = null;
					$keywords = $config->get("words");
					if (is_string($keywords) && strlen($keywords) < 1)
						$keywords = null;
						
					$alt_images = $config->get("alt_images");
				}
			}
		}
	}
	return [
		"title"       => $title,
		"description" => $description,
		"keywords"    => $keywords,
		"alt_images"  => $alt_images,
		"#context"    => [
			"entity"      => $entity,
			"entity_type" => $entity->getEntityTypeId()
		]
	];
}
/**
 * Implements hook_page_attachments_alter().
 */
function ws_taxonomy_meta_page_attachments_alter(array &$vars) {

	$vars['#cache']['tags'][] = 'taxonomy_term_list';

	$metas = _ws_taxonomy_meta_get_meta();
	if (count($metas) < 1) return;

	if (isset($metas["description"]))
		$description = $metas["description"];
	else
		$description = null;

	if (isset($metas["keywords"]))
		$keywords = $metas["keywords"];
	else
		$keywords = null;

	if ($keywords === null && $description === null)
		return;

	if (isset($vars["#attached"]["html_head"]))
		foreach ($vars["#attached"]["html_head"] as &$value) {
			if (isset($value[0]) && isset($value[1]))
			switch ($value[1]) {
				case 'description':
					if (isset($value[0]["#attributes"]["content"])) {
						$description = null;
					}
					break;
				case 'keywords':
					if (isset($value[0]["#attributes"]["content"])) {
						$keywords = null;
					}
					break;
			}
		}

	if ($keywords === null && $description === null)
		return;

	$token_service = \Drupal::token();

	if ($description !== null) {
		$description = $token_service->replace($description, [ $metas["#context"]["entity_type"] => $metas["#context"]["entity"] ], ['clear' => true]);
		$description = str_replace(["\n","\r"],"",strip_tags(html_entity_decode($description,ENT_COMPAT)));
		$vars["#attached"]["html_head"][] = [
			[
				"#tag"        => "meta",
				"#attributes" => [
					"name"    => "description",
					"content" => $description
				]
			],
			"description"
		];
	}

	if ($keywords !== null) {
		$keywords = $token_service->replace($keywords, [ $metas["#context"]["entity_type"] => $metas["#context"]["entity"] ], ['clear' => true]);
		$keywords = str_replace(["\n","\r"],"",strip_tags(html_entity_decode($keywords,ENT_COMPAT)));
		$vars["#attached"]["html_head"][] = [
			[
				"#tag"        => "meta",
				"#attributes" => [
					"name"    => "keywords",
					"content" => $keywords
				]
			],
			"keywords"
		];
	}
}
/**
 * Implements hook_preprocess_html().
 */
function ws_taxonomy_meta_preprocess_html(&$vars) {
	$vars['#cache']['tags'][] = 'taxonomy_term_list';

	$metas = _ws_taxonomy_meta_get_meta();
	if (count($metas) < 1) return;

	if (is_string($metas["title"]) && strlen($metas["title"]) > 0) {
		$token_service = \Drupal::token();
		$vars["head_title"]["title"] = $token_service->replace($metas["title"], [ $metas["#context"]["entity_type"] => $metas["#context"]["entity"] ], ['clear' => true]);
	}
}